A Minimum Spanning Tree (MST) is a subset of edges in a connected, edge-weighted (un)directed graph that connects every vertex within the graph.Together, all such subsets form what is called a minimum spanning tree.

There are two main algorithms to find the MST: Kruskal's and Prim's algorithm. 

1. **Kruskal’s Algorithm**: This algorithm starts by sorting all edges from lowest weight to highest. After that, it builds the MST one edge at a time, always adding the next lowest-weight edge that connects a vertex in the current MST to a vertex not yet included in the MST.

2. **Prim’s Algorithm**: This algorithm starts by sorting all vertices according to their distance from a given vertex (usually chosen as the first vertex added). Then it begins with adding to the MST the edge that connects the chosen vertex to its nearest neighbor, and then continues adding to the MST the next lowest-weight edge that connects a vertex in the current MST to a vertex not yet included in the MST.

To illustrate both of these algorithms using Python, we can use an adjacency matrix representation for our graph:
```python
import heapq
INF = int(1e9) # define infinity value

# function to find the parent node in the disjoint set
def find_parent(nodes, x):
  if nodes[x] != x:
    nodes[x] = find_parent(nodes, nodes[x]))
  return nodes[x]]

# function to implement Kruskal’s algorithm
def kruskal(n, edges):
  # initialize the disjoint set with each node as its own parent
  nodes = list(range(n+1))))
  mst_edges = [] # list to store the edges of the MST

  # create a priority queue and add all edges to it
  pq = [(weight, u, v) for (u, v), weight in edges.items()]
  heapq.heapify(pq)

  # iterate over the edges from lowest weight to highest
  while pq:
    weight, u, v = heapq.heappop(pq))
    if find_parent(nodes, u) != find_parent(nodes, v)):
      mst_edges.append((u, v), weight))

  return mst_edges
```
Both Kruskal’s and Prim’s algorithms can be used to solve the minimum spanning tree problem efficiently for a given connected graph.