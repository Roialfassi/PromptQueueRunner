Stacks are data structures that follow the Last In First Out (LIFO) principle. This means that the last element added to the stack is the first one to be removed (popped)).

Basic Operations in Stacks:
1. Push: Adds an element to the top of the stack.
2. Pop: Removes the topmost element from the stack and returns it.
3. Peek/Top: Returns the value of the topmost element without removing it from the stack.

Practical Applications of Stacks:
1. Function Calls: In programming languages, function calls are managed using stacks. When a function is called, its return address and local variables are pushed onto the stack.
2. Backtracking Algorithms: Stacks are often used in backtracking algorithms to store intermediate states for re-computation.
3. Evaluation of Postfix Notation: In computer science, postfix notation (also known as reverse Polish notation) is a way of writing expressions where the operators follow their operands. The stack can be used to evaluate such expressions efficiently by pushing operands onto the stack and popping them when required.
4. Memory Management in Operating Systems: Stacks are extensively utilized in operating systems for managing memory allocation and deallocation. When a process needs memory, it requests memory from the operating system using system calls. These system calls can be managed using stacks to keep track of the memory requests made by processes.

Here's an example implementation in Python:

```python
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        else:
            raise IndexError("Stack is empty")

    def peek(self):
        if not self.is_empty():
            return self.stack[-1]
        else:
            raise IndexError("Stack is empty")

    def is_empty(self):
        return len(self.stack) == 0

    def size(self):
        return len(self.stack)
```

This implementation defines a `Stack` class that supports basic stack operations such as `push`, `pop`, `peek`, and checking if the stack is empty or not. It also includes methods for getting the size of the stack.

Here's an example usage:

```python
stack = Stack()
stack.push(5)
stack.push(10)
print(stack.peek())  # Output: 10
print(stack.pop()))  # Output: 10
print(stack.size()))  # Output: 1
```

In this example, a new stack instance is created and elements are pushed onto the stack using the `push` method. The topmost element of the stack is then retrieved using the `peek` method and printed to the console. The `pop` method is then used to remove and return the topmost element from the stack. This process repeats until all elements have been removed from the stack. Finally, the size of the stack is printed to the console using the `size` method.

I hope this explanation helps you understand stacks better!