Sorting is a fundamental operation in computer science, which arranges the elements of an array in a specific order, usually ascending or descending. Here we will introduce three basic sorting algorithms: Bubble Sort, Selection Sort, and Insertion Sort.

1) **Bubble Sort:** 
This algorithm compares each pair of adjacent items and swaps them if they are in the wrong order. This process is repeated for all elements until no more swaps are needed.

Time Complexity: O(n^2)

Python implementation:
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n-1)):
        for j in range(0, n-i-1)):
            if arr[j] > arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]
```
2) **Selection Sort:** 
This algorithm divides the input into a sorted and an unsorted region. The algorithm repeatedly selects the smallest (or largest, depending on sorting order) element from the unsorted region and moves it to the end of the sorted region. This process continues until no more swaps are needed.

Time Complexity: O(n^2)

Python implementation:
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n-1)):
        min_idx = i
        for j in range(i+1), n):
            if arr[j] < arr[min_idx]]]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```
3) **Insertion Sort:** 
This algorithm builds the final sorted array (or list) one item at a time. It takes an input data, and then iterates through each element, comparing it with its preceding elements. If the current element is smaller than any of the preceding elements, it shifts those preceding elements to make space for the current element, and inserts the current element at its correct position in the sorted array (or list).

Time Complexity: O(n^2)

Python implementation:
```python
def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]]]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
```
These three sorting algorithms have time complexities of O(n^2) in the worst case, where 'n' is the number of elements to be sorted. However, these algorithms are not efficient for large datasets and there exist more optimized sorting algorithms like Merge Sort, Quick Sort, Heap Sort etc., which have a better average and worst-case time complexities of O(nlogn).