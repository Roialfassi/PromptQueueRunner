Here's how I would approach this problem:

Firstly, we need to understand the different types of queries that we will be performing.

1) Fetching Data: We want to fetch as much data as possible in a single query for efficiency. 

2) Updating Data: For updating, it's better to use parameterized queries or stored procedures to avoid SQL injection attacks and to improve performance by allowing the database to cache execution plans.

3) Inserting Data: When inserting new records, it's important to follow best practices for data integrity and performance. This might include using auto-incrementing primary keys, setting appropriate indexes on frequently queried columns, and using batch processing techniques to minimize the number of database round trips required to insert or update multiple records at once.

Here's an example function in Python that demonstrates how these best practices can be applied to optimize queries for fetching, updating, and inserting order data:
```python
import sqlite3
def optimize_queries(conn):
    # Enable database connection pooling
    conn.execute("PRAGMA pool_size=10, min_pool_size=1;")

    # Set up a prepared statement for fetching orders
    fetch_orders_stmt = conn.execute("SELECT * FROM orders;")

    # Set up a stored procedure for updating orders
    conn.execute("""CREATE PROCEDURE update_order(IN order_id INTEGER, IN quantity INTEGER)
BEGIN
    UPDATE orders SET quantity=quantity+? WHERE order_id=?;
END;""")

    # Set up a stored procedure for inserting orders
    conn.execute("""CREATE PROCEDURE insert_order(IN product_id INTEGER, IN customer_id INTEGER, IN quantity INTEGER)
BEGIN
    INSERT INTO orders (product_id, customer_id, quantity) VALUES (?, ?, ?);
END;""")

    # Return the optimized queries function
    return optimize_queries
```
This function takes in a database connection object as an argument and returns the same function for method chaining.

The function first enables database connection pooling to improve performance by allowing the database to cache execution plans.

Next, it sets up a prepared statement for fetching orders from the `orders` table. This approach is used to optimize query performance because it allows the database to cache the execution plan and reuse it when executing the same query again.

After setting up the prepared statement, the function then creates a stored procedure for updating order records in the `orders` table. The stored procedure takes in three parameters: `order_id`, `quantity`, and `customer_id`. This approach is used to optimize update performance because it allows the database to cache the execution plan and reuse it when executing the same update query again.

Finally, the function creates a stored procedure for inserting order records into the `orders` table. The stored procedure takes in three parameters: `product_id`, `customer_id`, and `quantity`. This approach is used to optimize insert performance because it allows the database to cache the execution plan and reuse it when executing the same insert query again.

Overall, this function demonstrates how best practices for data integrity and performance can be applied to optimize queries for fetching, updating, and inserting order data in a SQLite database.