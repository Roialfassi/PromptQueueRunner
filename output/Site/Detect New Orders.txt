Here is an example of how this problem could be approached using Python, particularly pandas for data manipulation and SQLAlchemy for database interaction:

```python
import pandas as pd
from sqlalchemy import create_engine

# Function to identify new orders
def find_new_orders(scraped_data, previously_stored_data):

    # Convert the scraped data and previously stored data into pandas DataFrames
    df_scraped = pd.DataFrame(scraped_data)
    df_previous = pd.DataFrame(previously_stored_data)

    # Merge the two DataFrames on a common key (e.g., order ID)
    merged_df = pd.merge(df_scraped, df_previous, how='left', on='order_id')

    # Identify rows in the merged DataFrame where the 'status' column in the scraped data is different than the corresponding row in the previously stored data
    new_orders = merged_df[(merged_df['status'] != merged_df['previous_status']) & (merged_df['order_id'].isnull())]

    return new_orders
```
This function takes in two arguments: `scraped_data` and `previously_stored_data`. Both of these arguments should be lists or arrays, where each element represents a single order.

The function first converts the scraped data and previously stored data into pandas DataFrames. It then merges the two DataFrames on a common key (e.g., order ID).

Finally, the function identifies rows in the merged DataFrame where the 'status' column in the scraped data is different than the corresponding row in the previously stored data. These rows represent new orders. The function returns these new orders as a pandas DataFrame